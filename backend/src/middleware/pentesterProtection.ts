/**
 * Pentester Protection Middleware
 * Detects and blocks security testing tools and pentesting attempts
 */

import crypto from "crypto";
import { NextFunction, Request, Response } from "express";
import prisma from "../prismaClient";
import { logger } from "../utils/logger";

class PentesterProtectionService {
  private suspiciousIPs = new Map<string, number>();
  private blockedIPs = new Set<string>();

  /**
   * Detect pentesting tools
   */
  detectPentester(req: Request): {
    isPentester: boolean;
    confidence: number;
    tools: string[];
  } {
    const tools: string[] = [];
    let confidence = 0;

    const userAgent = req.headers["user-agent"] || "";
    const ip = this.getClientIP(req);

    // Known pentesting tools
    const pentestTools = [
      "burp",
      "burpsuite",
      "sqlmap",
      "nmap",
      "nikto",
      "metasploit",
      "wireshark",
      "fiddler",
      "charles",
      "postman",
      "insomnia",
      "curl",
      "wget",
      "python-requests",
      "go-http-client",
      "scanner",
      "exploit",
      "hack",
      "penetration",
      "security-test",
      "vulnerability-scanner",
    ];

    // Check user agent
    const uaLower = userAgent.toLowerCase();
    for (const tool of pentestTools) {
      if (uaLower.includes(tool)) {
        tools.push(tool);
        confidence += 0.3;
      }
    }

    // Check for common pentest headers
    const pentestHeaders = ["x-scan", "x-scanner", "x-pentest", "x-security-test", "x-burp", "x-sqlmap"];

    for (const header of pentestHeaders) {
      if (req.headers[header.toLowerCase()]) {
        tools.push(header);
        confidence += 0.4;
      }
    }

    // Check for suspicious paths (common pentest targets)
    const pentestPaths = [
      "/admin",
      "/api/admin",
      "/.env",
      "/config",
      "/phpinfo",
      "/wp-admin",
      "/wp-login",
      "/.git",
      "/.svn",
      "/backup",
      "/test",
      "/debug",
      "/phpmyadmin",
      "/.well-known",
    ];

    const path = req.path.toLowerCase();
    for (const testPath of pentestPaths) {
      if (path.includes(testPath)) {
        tools.push(`path_scan:${testPath}`);
        confidence += 0.2;
      }
    }

    // Check for SQL injection patterns
    const sqlPatterns = [
      /(\bOR\b|\bAND\b).*=.*(\bOR\b|\bAND\b)/i,
      /\b(union|select|insert|update|delete|drop)\b.*\b(from|into|table)\b/i,
      /'(\s|%27).*(\s|%27)(or|and)/i,
      /(\%27)|(\')|(\-\-)|(\%23)/i,
    ];

    const bodyString = JSON.stringify(req.body || {});
    const queryString = JSON.stringify(req.query || {});

    for (const pattern of sqlPatterns) {
      if (pattern.test(bodyString) || pattern.test(queryString)) {
        tools.push("sql_injection_attempt");
        confidence += 0.5;
      }
    }

    // Check for XSS patterns
    const xssPatterns = [/<script[^>]*>/gi, /javascript:/gi, /on\w+\s*=/gi, /<iframe[^>]*>/gi, /<img[^>]*onerror/gi];

    for (const pattern of xssPatterns) {
      if (pattern.test(bodyString) || pattern.test(queryString)) {
        tools.push("xss_attempt");
        confidence += 0.4;
      }
    }

    // Check for path traversal
    const pathTraversalPatterns = [/\.\.\//g, /\.\.\\/g, /\.\.%2f/gi, /\.\.%5c/gi];

    for (const pattern of pathTraversalPatterns) {
      if (pattern.test(bodyString) || pattern.test(queryString) || pattern.test(path)) {
        tools.push("path_traversal_attempt");
        confidence += 0.4;
      }
    }

    // Check for command injection
    const commandInjectionPatterns = [
      /;\s*(rm|del|cat|ls|dir|pwd|whoami|id|uname)/i,
      /\|\s*(rm|del|cat|ls|dir|pwd|whoami|id|uname)/i,
      /`\s*(rm|del|cat|ls|dir|pwd|whoami|id|uname)/i,
      /\$\s*\(/i,
    ];

    for (const pattern of commandInjectionPatterns) {
      if (pattern.test(bodyString) || pattern.test(queryString)) {
        tools.push("command_injection_attempt");
        confidence += 0.5;
      }
    }

    return {
      isPentester: confidence > 0.5,
      confidence: Math.min(confidence, 1.0),
      tools,
    };
  }

  /**
   * Get client IP
   */
  private getClientIP(req: Request): string {
    return (
      (req.headers["x-forwarded-for"] as string)?.split(",")[0] ||
      (req.headers["x-real-ip"] as string) ||
      req.ip ||
      req.socket.remoteAddress ||
      "unknown"
    );
  }

  /**
   * Middleware function
   */
  middleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        // Skip health checks
        if (req.path === "/api/health" || req.path === "/health") {
          return next();
        }

        const ip = this.getClientIP(req);

        // Check if IP is already blocked
        if (this.blockedIPs.has(ip)) {
          return res.status(403).json({
            error: "Access denied",
            message: "IP blocked for security reasons",
          });
        }

        // Detect pentester
        const pentester = this.detectPentester(req);

        if (pentester.isPentester) {
          const count = this.suspiciousIPs.get(ip) || 0;
          this.suspiciousIPs.set(ip, count + 1);

          logger.warn(`ðŸš« Pentester detected from ${ip}:`, {
            tools: pentester.tools,
            confidence: pentester.confidence,
            count: count + 1,
            path: req.path,
          });

          // Log security event
          await prisma.security_events.create({
            data: {
              id: crypto.randomUUID(),
              type: "PENTESTER_DETECTED",
              severity: "CRITICAL",
              ipAddress: ip,
              userAgent: req.headers["user-agent"] || "",
              details: {
                tools: pentester.tools,
                confidence: pentester.confidence,
                path: req.path,
                method: req.method,
              },
              createdAt: new Date(),
            },
          });

          // Block after 2 attempts
          if (count >= 1) {
            this.blockedIPs.add(ip);
            return res.status(403).json({
              error: "Access denied",
              message: "Security testing not allowed",
            });
          }

          // Return generic error to avoid information leakage
          return res.status(404).json({
            error: "Not found",
          });
        }

        next();
      } catch (error) {
        logger.error("Pentester protection middleware error:", error);
        next();
      }
    };
  }
}

const pentesterProtection = new PentesterProtectionService();
export default pentesterProtection;
